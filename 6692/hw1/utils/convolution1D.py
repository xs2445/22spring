"""
This file contains functions for creating 1D convolution signals and calculating convolution/correlation.

E6692 Spring 2022
"""

from math import pi, sqrt, exp


def create_rect_signal(base_ampl=0, base_length=128, function_ampl=1, function_length=12):
    """
    Generate a 1D rectangular signal that spans the range of the convolution/correlation.
    
    params:
        base_ampl (int): the baseline value of the signal
        base_length (int): the length of the signal
        function_ampl (int): the amplitude of the signal
        function_length (int): the length of the rectangular signal
        
    returns:
        signal (list of ints): the rectangular signal
    """
    #####################################################################################
    # --------------------------- YOUR IMPLEMENTATION HERE ---------------------------- #
    #####################################################################################
    
    signal =  [function_ampl]*function_length + [base_ampl]*base_length
    
    #####################################################################################
    # --------------------------- END YOUR IMPLEMENTATION ----------------------------- #
    #####################################################################################
    
    return signal
    

def create_1dconv_mask_sawtooth(base_ampl=1, end_ampl=8, steps=1):
    """
    Generate a 1D sawtooth mask. The sawtooth is a 1D linearly increasing
    mask with slope (end_ampl - base_ampl) / steps .
    
    params:
        base_ampl (int): the baseline value (min) of the signal
        end_ampl (int): the final value (max) of the signal
        steps (int): the number of steps comprising the sawtooth signal
        
    returns:
        signal (list of ints): the sawtooth signal
    """
    #####################################################################################
    # --------------------------- YOUR IMPLEMENTATION HERE ---------------------------- #
    #####################################################################################
    
    slope = (end_ampl-base_ampl) / steps
    signal = []
    for i in range(steps+1):
        signal.append(i*slope + base_ampl)
    
    #####################################################################################
    # --------------------------- END YOUR IMPLEMENTATION ----------------------------- #
    #####################################################################################
    
    return signal


def calc_conv(conv_mask, input_signal):
    """
    Calculate the 1D convolution between input_signal and conv_mask.
    
    params:
        conv_mask (list of ints): the convolutional mask generated by create_1dconv_mask_sawtooth()
        input_signal (list of ints): the signal generated by create_rect_signal()
        
    returns:
        output (list of ints): the 1D convolution between input_signal and conv_mask
    """
    #####################################################################################
    # --------------------------- YOUR IMPLEMENTATION HERE ---------------------------- #
    #####################################################################################
    
    # the width of the mask
    width_mask = len(conv_mask)
    # padding to make the length of output equals the length of input
    pad = (width_mask+1)//2
    padded = [0]*pad + input_signal + [0]*pad
    output = []
    for i in range(len(padded)-width_mask):
        out_i = 0
        end_idx = i+width_mask
        for j in range(width_mask):
            out_i += padded[end_idx-j-1] * conv_mask[j]
        output.append(out_i)
    
    #####################################################################################
    # --------------------------- END YOUR IMPLEMENTATION ----------------------------- #
    #####################################################################################
            
    return output


def calc_corr(corr_mask, input_signal):
    """
    Calculate the 1D correlation between input_signal and conv_mask.
    
    params:
        corr_mask (list of ints): the correlation mask generated by create_1dconv_mask_sawtooth()
        input_signal (list of ints): the signal generated by create_rect_signal()
        
    returns:
        output (list of ints): the 1D correlation between input_signal and conv_mask
    """
    #####################################################################################
    # --------------------------- YOUR IMPLEMENTATION HERE ---------------------------- #
    #####################################################################################
    
    # method 1: correlation is convolution with a reversed mask

    conv_mask = [ele for ele in reversed(corr_mask)]
    output = calc_conv(conv_mask, input_signal)

    # method 2: explicit correlation

    # # the width of the mask
    # width_mask = len(corr_mask)
    # # padding to make the length of output equals the length of input
    # pad = (width_mask+1)//2
    # padded = [0]*pad + input_signal + [0]*pad
    # output = []
    # for i in range(len(padded)-width_mask):
    #     out_i = 0
    #     for j in range(width_mask):
    #         out_i += padded[i+j] * corr_mask[j]
    #     output.append(out_i)    

    #####################################################################################
    # --------------------------- END YOUR IMPLEMENTATION ----------------------------- #
    #####################################################################################
            
    return output


def create_custom_mask(length, miu=0, sigma=1):
    """
    Gaussian mask generator
    
    params:
        
    returns:
        signal: Gaussian mask
    """

    start = -(length-1)//2
    signal = []
    amp = 0
    for i in range(length):
        out_i = gaussian(start+i, miu, sigma)
        amp += out_i
        signal.append(out_i)
    # make the integration of mask to be 1
    signal = [ele/amp for ele in signal]

    return signal

def gaussian(x, miu=0, sigma=1):
    """
    Gaussian distribution
    """
    return 1/(sqrt(2*pi*sigma**2))*exp(-(x-miu)**2/(2*sigma**2))